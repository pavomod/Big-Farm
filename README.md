# Lab2 progetto finale (BIG farm)
Documentazione progetto finale anno 2021/22

 
= *farm.c* =

**Gestione_option()**: ci consente di valutare la presenza di parametri opzionali e, nel caso ce ne sia qualcuno, la funzione tramite uno switch modifica il valore della relativa variabile associata (verificando prima che il valore associato al parametro opzionale sia valido) che hanno come valore di default: **nthread=4**, **qlen=8**, **delay=0**. Ogni volta che viene valutato un parametro opzionale incrementiamo di 2 la variabile **conta_opt** che conta quanti parametri opzionali (e il relativo valore associato) sono stati passati da console, così che successivamente quando andremo a valutare i restanti parametri passati da console (i file binari) sappiamo da che posizioni in *argv* partire (get_opt() ordina *argv* spostando nelle prime posizioni i parametri opzionali).

**main():** Il thread principale esegue la lettura dei parametri passati da console tramite un ciclo for , leggendo dalla posizione **conta_opt** fino ad argc. Il thread principale si sincronizza con i thread consumatori tramite una mutex e due condition variables (**cthread** su cui il padre attende un segnale dai thread,**cpadre** su cui i thread secondari attendono un segnale dal thread principale) attendendo che si verifichino le condizioni necessarie per eseguire il loro compito (**dati**:indica quanti dati ci sono da elabore, **free_block**: indica quante celle sono libere nel buffer). Quando il thread principale ha terminato di inserire nel buffer tutti i nomi dei file passati da console, inserisce **nthread** stringhe vuote (un file non può avere come nome una stringa vuota).
Per gestire il segnale *SIGINT* ho modificato l'handler di default con la mia funzione **handl()** che alla ricezione del segnale setta a 1 la variabile globale **segnale** così che il thread principale termini anticipatamente e si metta in attesa che i thread consumatri finiscano di valutare i file già presenti nel buffer.

**tbody()**: Gestisce i thread consumatori e si sincronizzano con il padre come spiegato nella funzione **main()**. Per ogni stringa diversa da "" stringa nel buffer i thread verificano se esiste un file associato a quel nome e nel caso esista aggiornano la variabile somma come somma+= i * file[i]. Calcolata la somma totale, per ogni file viene inviata al server tramite la funzione **comunicazione()** la coppia **nome , somma**. Nel caso il thread consumatore legga nel buffer la stringa vuota termina.

**comunicazione():** si occupa di stabile una connesione tramite socket con il server e di inviare la coppia **nome , somma**. inizialmente concatena il nome del file e la somma (facendo il cast da long a string) separati dal carattere *"/"* (carattere di separazione scelto perchè un file non può contenere all'interno del suo nome questo carattere), convertendo carattere per carattere tutta la stringa in un array di interi (per poterla inviare tramite socket). Prima di tutto invia al server la lunghezza dell'array (così che il server possa calcolare il numero di byte che dovrà ricevere), e successivamente invia intero per intero (ogni intero corrisponde ad un carattere del messaggio) il messaggio al server.

= *client.c* =

**main():** se non vengono passati parametri da console la funzione main chiama la funzione **comunicazione(modalità,long)** passando *-1* e *0* come parametro, altrimenti invoca la funzione tante volte quanti parametri sono stati passati da console, passando volta per volta come parametro *1* e il valore *long* da inviare al server.

**comunicazione():** se la funzione riceve come modalità il valore *-1*, allora invia al server soltanto il valore *-1* che farà capire al server che la richiesta del client è quella di stampare tutte le coppie e ignora il secondo parametro (il valore passato al server indica la dimensione del messaggio che andrà a ricevere, essendo una dimensione negativa e non può essere inviato un messaggio con dimensione negativa, il servere capirà quale tipo di richiesta sta facendo il client). Se invece la funzione riceve come modalità il valore 1, converte il long in stringa e successivamente la stringa (carattere per carattere) in un array di interi (così da poterla inviare tramite socket), successivamente la funzione invia prima la dimensione del messaggio che andrà a inviare, e successivamente il messaggio vero e proprio (essendo che la dimensione sarà necessariamente positiva, il server attenderà il messaggio e capirà la richiesta di stampare la coppia **somma , nome** richiesta dal client).

= *collector.py* =

Il server ad ogni richiesta di connesione avvia un thread che tramite il metodo **gestisci_connesioni** si occupa di elaborare la richiesta di un client, accedendo al dizionario in cui sono contenute le coppie in mutua esclusione.

**gestisci_connesioni():** per ogni connesione il server si mette in attesa di ricevere un intero che indica la dimensione del messaggio che andrà a ricevere. Se la dimensione è -1 vuol dire che non dobbiamo aspettarci un ulteriore messaggio e che la richiesta ricevuta è quella di stampare tutte le coppie, ordinate in modo crescente, salvate fino adesso. In caso la dimensione sia positiva, il server attenderà il messaggio che consiste in un insieme di interi, che castati e concatenati tra di loro formeranno il messaggio. Se il messaggio contiene il carattere **"/"** allora la richiesta del client è quella di dividere il messaggio e salvare la coppia **nome , somma** separati dal carattere **"/"**. Se il carattere **"/"** non è presente nel messaggio, allora la richiesta del client è quella di stampare tutti **nomi** dei file che hanno come **somma** quella indicata nel messaggio.

**trova():** Se il dizionario è vuoto o la chiave richiesta non è presente nel dizionario il server stamperà **Nessun file**, mentre se la chiave è presente nel dizionario, allora verrà stampato il valore associao.

**stampa():** Salva tutte le chiavi in una lista e successivamente la ordina, in fine viene stampato ogni valore nel dizionario interrogandolo con le chiavi ordinate presenti nella lista. Se il dizionario è vuoto viene stampata la stringa **"Nessun file"**
